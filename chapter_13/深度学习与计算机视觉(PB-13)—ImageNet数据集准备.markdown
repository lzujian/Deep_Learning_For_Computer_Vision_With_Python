<article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://lonepatient.top/2018/07/02/Deep_Learning_For_Computer_Vision_With_Python_PB_13.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="eamlife"><meta itemprop="description" content=""><meta itemprop="image" content="/images/touxiang.jpeg"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="eamlife's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">深度学习与计算机视觉(PB-13)—ImageNet数据集准备</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T07:27:08+08:00">2018-07-01 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/深度学习/" itemprop="url" rel="index"><span itemprop="name">深度学习</span> </a></span>， <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/深度学习/计算机视觉/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/07/02/Deep_Learning_For_Computer_Vision_With_Python_PB_13.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2018/07/02/Deep_Learning_For_Computer_Vision_With_Python_PB_13.html" itemprop="commentCount">0</span> </a></span><span id="/2018/07/02/Deep_Learning_For_Computer_Vision_With_Python_PB_13.html" class="leancloud_visitors" data-flag-title="深度学习与计算机视觉(PB-13)—ImageNet数据集准备"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数:</span> <span class="leancloud-visitors-count">2</span></span><div class="post-wordcount"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计:</span> <span title="字数统计">7.5k 字</span></div></div></header><div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"><span id="imgCopy"><i class="fa fa-paste fa-fw"></i></span><span id="imgSuccess" style="display: none;"><i class="fa fa-check-circle fa-fw" aria-hidden="true"></i></span></div><div class="post-body" itemprop="articleBody"><p>前面几节内容中，我们都是对小数据集（相对于工业界而言）进行实验，使用CPU环境也可以完美地实现。接下来，我们将使用ImageNet数据集进行实验，该数据集比较大，需要在GPU环境下进行。在对ImageNet数据进行建模之前，我们首先来认识下ImageNet数据集以及对该数据集进行预处理。</p><a id="more"></a><h2 id="ImageNet数据集介绍"><a href="#ImageNet数据集介绍" class="headerlink" title="ImageNet数据集介绍"></a>ImageNet数据集介绍</h2><p>ImageNet是一个计算机视觉系统识别项目，是目前世界上图像识别最大的数据库。是美国斯坦福的计算机科学家，模拟人类的识别系统建立的。能够从图片中识别物体。ImageNet是一个非常有前景的研究项目，未来用在机器人身上，就可以直接辨认物品和人了。超过1400万的图像URL被ImageNet手动注释，以指示图片中的对象;在至少一百万张图像中，还提供了边界框。ImageNet包含2万多个类别; 一个典型的类别，如“气球”或“草莓”，每个类包含数百张图像。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>ImageNet数据集可以直接从<a href="http://image-net.org/challenges/LSVRC/2016/download-images-8r28.php" target="_blank" rel="noopener">该地址</a>中下载，当然你可以根据对应的任务选择相应的数据集下载即可。</p><p><strong>备注</strong>：我花了好几天将官网的数据下载完，速度比较慢，如果你们有需要的，可以留言，我上传到百度网盘，分享给你们（很容易被和谐，所以单独发给你们）。</p><h2 id="ImageNet数据说明"><a href="#ImageNet数据说明" class="headerlink" title="ImageNet数据说明"></a>ImageNet数据说明</h2><p>下载完ImageNet数据集之后，你会发现里面包含了很多文件，虽然磁盘上有将近2百万的图片数据，但是没有一个比较直观的名字,且没有一个很明显的方式能够知道每张图像对应的标签信息，当我们对这些数据集训练一个特定的卷积神经网络时，需要提前进行预处理。</p><p>在本节中，首先，我们将分析ImageNet数据文件结构，包括原始图像数据和开发工具包(“DevKit”)。之后，我们将编写一个Python脚本，解析ImageNet文件和对应标签，即将给定的输入文件名映射到相应的标签(每行一个文件名和标签)。</p><p>最后，我们利用Tensorflow对数据创建更高效的TFRecord (.tfrecords)文件。当数据大到无法放入内存时，我们可以使用这些文件数据进行训练深度学习模型。后面我们将看到，这种.tfrecords格式不仅比HDF5更紧凑，而且它的I/O效率也更高，使我们能够更快地训练网络。</p><p>当数据处理完之后，就方便我们后续对ImageNet数据集从头开始训练自定义的CNNs网络结构。</p><h3 id="ImageNet文件结构"><a href="#ImageNet文件结构" class="headerlink" title="ImageNet文件结构"></a>ImageNet文件结构</h3><p>首先,我们先认识下ImageNet数据文件结构。假设你已经下载完了ILSVRC2016_CLS_LOC.tar.gz文件(数据本身比较大，约166G）。对文件进行解压:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xvf ILSVRC2016_CLS-LOC.tar.gz</span></span><br></pre></td></tr></tbody></table></figure></div><p>这个解压相对而言需要花点时间，因为本身数据文件比较多。</p><p>解压完成之后，将得到一个名为ILSVRC的目录:</p><p>进入ILSVRC文件夹，您将发现三个子目录:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ILSVRC</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Annotations  Data  ImageSets</span><br></pre></td></tr></tbody></table></figure></div><p>其中:</p><ul><li>Annotations：物体位置标注数据文件，一般是在物体检测任务中使用到，目前我们可以忽略这个数据集</li><li>Data：数据文件夹，这个是我们需要重点关注的，里面包含了train、val和test原始图像数据</li><li>ImageSets：图像对应的属性信息</li></ul><p>进入Data数据目录，我们将看到一个名为CLS-LOC的子目录:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> ls Data/</span></span><br><span class="line">CLS-LOC</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls Data/CLS-LOC</span></span><br><span class="line">test  train  val</span><br></pre></td></tr></tbody></table></figure></div><p>而在子目录，我们将找到我们需要处理的train、val和test数据集。</p><p>接下来，我们将重点分析这三个目录文件。</p><h3 id="test目录"><a href="#test目录" class="headerlink" title="test目录"></a>test目录</h3><p>test目录包含10万张图像(1000个类，每一类中都有100个数据)，如:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l Data/CLS-LOC/<span class="built_in">test</span>/ | head -n 10</span></span><br><span class="line">-rw-r--r-- 1 lone lone   33889 7月   1  2012 ILSVRC2012_test_00000001.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  122117 7月   1  2012 ILSVRC2012_test_00000002.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone   26831 7月   1  2012 ILSVRC2012_test_00000003.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  124722 7月   1  2012 ILSVRC2012_test_00000004.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone   98627 7月   1  2012 ILSVRC2012_test_00000005.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  211157 7月   1  2012 ILSVRC2012_test_00000006.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  219906 7月   1  2012 ILSVRC2012_test_00000007.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  181734 7月   1  2012 ILSVRC2012_test_00000008.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone   10696 7月   1  2012 ILSVRC2012_test_00000009.JPEG</span><br></pre></td></tr></tbody></table></figure></div><p>这些数据是没有对应的标签信息，因此，我们无法将这些图像数据直接用于我们的实验。实际上每年都会有一次ILSVRC比赛，使用的数据就是ImageNet数据，为了保证这个比赛公平(并确保没有人作弊)，test数据集的标签是保密的。</p><p>首先，每个参赛者/组织使用train和val数据集来训练和评估他们的算法。一旦他们训练好模型，然后就会在test数据集上进行预测。随后将预测结果上传到ImageNet服务器，并与真实标签进行比较（任何情况下，任何参赛者都不能使用test数据集的真实标签）。最后，ImageNet服务器将返回它们的总体精度。</p><p>所以，我们将忽略test数据集目录，而是从train数据集中提取一部分子集作为test数据集。这样，我们可以在本地评估整个模型的性能。</p><h3 id="train目录"><a href="#train目录" class="headerlink" title="train目录"></a>train目录</h3><p>train目录中由一系列子目录组成,如下所示：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l Data/CLS-LOC/train/ | head -n 10</span></span><br><span class="line">drwxr-xr-x 2 lone lone 57344 9月  29  2014 n01440764</span><br><span class="line">drwxr-xr-x 2 lone lone 65536 9月  29  2014 n01443537</span><br><span class="line">drwxr-xr-x 2 lone lone 57344 9月  29  2014 n01484850</span><br><span class="line">drwxr-xr-x 2 lone lone 65536 9月  29  2014 n01491361</span><br><span class="line">drwxr-xr-x 2 lone lone 61440 9月  29  2014 n01494475</span><br><span class="line">drwxr-xr-x 2 lone lone 61440 9月  29  2014 n01496331</span><br><span class="line">drwxr-xr-x 2 lone lone 49152 9月  29  2014 n01498041</span><br><span class="line">drwxr-xr-x 2 lone lone 65536 9月  29  2014 n01514668</span><br><span class="line">drwxr-xr-x 2 lone lone 61440 9月  29  2014 n01514859</span><br></pre></td></tr></tbody></table></figure></div><p>这些目录名称看样子好像没有包含任何图像信息。实际上，ImageNet数据集是根据WordNet IDs映射的，称为同义词集或简称为“syn sets”。每个ID映射到特定的数据标签，如金鱼、秃鹰、飞机或吉他。因此，这些文件名实际上是每一类对应的WordNet ID，并且在这些标签子目录中，每个类大约有732到1300张图像。</p><p>例如，WordNet ID为n01440764的子目录包含了1300张 “tench”图像，“tench”是一种欧洲淡水鱼，与minnow类很相似(如图13.1所示):</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l Data/CLS-LOC/train/n01440764/*.JPEG | wc -l</span></span><br><span class="line">1300</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l Data/CLS-LOC/train/n01440764/*.JPEG | head -n 5</span></span><br><span class="line">-rw-r--r-- 1 lone lone   13697 6月  11  2012 Data/CLS-LOC/train/n01440764/n01440764_10026.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone    9673 6月  11  2012 Data/CLS-LOC/train/n01440764/n01440764_10027.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone   67029 6月  11  2012 Data/CLS-LOC/train/n01440764/n01440764_10029.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  146489 6月  11  2012 Data/CLS-LOC/train/n01440764/n01440764_10040.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone    6350 6月  11  2012 Data/CLS-LOC/train/n01440764/n01440764_10042.JPEG</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://lonepatient-1257945978.cos.ap-chengdu.myqcloud.com/18-10-25/42580132.jpg" class="fancybox fancybox.image" rel="group"><img src="https://lonepatient-1257945978.cos.ap-chengdu.myqcloud.com/18-10-25/42580132.jpg" alt=""></a></p><center>图13.1</center><p>因此，对于这些由WordNet IDs命名的train数据集，我们将直接与train_cls.txt进行匹配，可以直接得到数据对应的标签名称。</p><h3 id="val目录"><a href="#val目录" class="headerlink" title="val目录"></a>val目录</h3><p>与test数据集目录类似，val数据集目录包含50000张图像(1000个类中每类有50张图像):</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l Data/CLS-LOC/val/*.JPEG | wc -l</span></span><br><span class="line">50000</span><br></pre></td></tr></tbody></table></figure></div><p>这50000张图像直接存放在一个目录文件夹中，这意味着我们无法使用目录名直接映射得到数据对应的标签名称。</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l Data/CLS-LOC/val/ | head -n 10</span></span><br><span class="line">total 6648996</span><br><span class="line">-rw-r--r-- 1 lone lone  109527 6月  13  2012 ILSVRC2012_val_00000001.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  140296 6月  13  2012 ILSVRC2012_val_00000002.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  122660 6月  13  2012 ILSVRC2012_val_00000003.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone   84885 6月  13  2012 ILSVRC2012_val_00000004.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  130340 6月  13  2012 ILSVRC2012_val_00000005.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  151397 6月  13  2012 ILSVRC2012_val_00000006.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  165863 6月  13  2012 ILSVRC2012_val_00000007.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  107423 6月  13  2012 ILSVRC2012_val_00000008.JPEG</span><br><span class="line">-rw-r--r-- 1 lone lone  114708 6月  13  2012 ILSVRC2012_val_00000009.JPEG</span><br></pre></td></tr></tbody></table></figure></div><p>另外，通过检查文件名，我们没有看到类似于WordNet IDs中ID命名格式。但是，在val.txt文件中，提供了val数据集文件名到类标签的映射关系。</p><h3 id="ImageSets目录"><a href="#ImageSets目录" class="headerlink" title="ImageSets目录"></a>ImageSets目录</h3><p>ImageSets目录中主要存放的是标签的映射关系数据。如下所示:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">$ cd ImageSets/</span><br><span class="line">$ ls</span><br><span class="line">CLS-LOC</span><br><span class="line">$ cd CLS-LOC</span><br><span class="line">$ ls</span><br><span class="line">test.txt  train_cls.txt  train_loc.txt  val.txt</span><br></pre></td></tr></tbody></table></figure></div><p>目录中包含了四个txt文件，我们可以忽略test.txt文件，因为我们将从train数据集中构建自己的test数据集。train_cls.txt(其中“cls”代表“分类”)包含了train数据集(1281167张图像)的文件名映射到标签数据，val.txt包含了val数据集(50,000)的标签数据（直接对应index）。即:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l train_cls.txt val.txt</span></span><br><span class="line"> 1281167 train_cls.txt</span><br><span class="line">   50000 val.txt</span><br><span class="line"> 1331167 total</span><br></pre></td></tr></tbody></table></figure></div><p>两个文件总共包含了1331167张需要处理的图像。首先，我们可以看到train_cls.txt文件内容，每行都是由一个基本的图像文件名(没有文件扩展名)和一个唯一的整数ID组成，即:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> head -n 10 train_cls.txt</span></span><br><span class="line">n01440764/n01440764_10026 1</span><br><span class="line">n01440764/n01440764_10027 2</span><br><span class="line">n01440764/n01440764_10029 3</span><br><span class="line">n01440764/n01440764_10040 4</span><br><span class="line">n01440764/n01440764_10042 5</span><br><span class="line">n01440764/n01440764_10043 6</span><br><span class="line">n01440764/n01440764_10048 7</span><br><span class="line">n01440764/n01440764_10066 8</span><br><span class="line">n01440764/n01440764_10074 9</span><br><span class="line">n01440764/n01440764_10095 10</span><br></pre></td></tr></tbody></table></figure></div><p>该整数只是一个递增的计数器，没有特殊含义。val.txt也类似，即：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> head -n 10 val.txt</span></span><br><span class="line">ILSVRC2012_val_00000001 1</span><br><span class="line">ILSVRC2012_val_00000002 2</span><br><span class="line">ILSVRC2012_val_00000003 3</span><br><span class="line">ILSVRC2012_val_00000004 4</span><br><span class="line">ILSVRC2012_val_00000005 5</span><br><span class="line">ILSVRC2012_val_00000006 6</span><br><span class="line">ILSVRC2012_val_00000007 7</span><br><span class="line">ILSVRC2012_val_00000008 8</span><br><span class="line">ILSVRC2012_val_00000009 9</span><br><span class="line">ILSVRC2012_val_00000010 10</span><br></pre></td></tr></tbody></table></figure></div><p><strong>备注</strong>：这些整数ID并不太有用，除非我们需要确定“黑名单”图像——由ImageNet数据集管理员标记为“黑名单”的图像，由于该图像的类标签过于模糊，因此在评估过程中我们不考虑这些图像。在后部分内容中，我们将遍历所有被列入黑名单的图像，并通过该整数ID映射从数据集中删除。</p><p>使用train_cls.txt和val.txt文件，有一个好处就是我们不必使用额外的路径类似<code>paths.list_images</code>将train和val数据列举出。相反，我们只需要遍历这两个文件，并合理拼接图像信息，就可以构建TFRecord文件。</p><h3 id="DevKit目录"><a href="#DevKit目录" class="headerlink" title="DevKit目录"></a>DevKit目录</h3><p>除了下载原始图像本身外，还需要下载ILSVRC2016_devkit.tar.gz。这个文件包含实际的索引文件、validation数据中黑名单图像id和图像文件名映射到相应的实际类标签等数据。将ILSVRC2016_devkit.tar.gz文件放到与ILSVRC同目录并进行解压:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xvf ILSVRC2016_devkit.tar.gz</span></span><br></pre></td></tr></tbody></table></figure></div><p>在ILSVRC目录中，你将会发现新增了一个devkit文件目录:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ILSVRC/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Annotations  Data  devkit  ImageSets</span><br></pre></td></tr></tbody></table></figure></div><p>进入devkit目录:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> devkit/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">COPYING  data  evaluation  readme.txt</span><br></pre></td></tr></tbody></table></figure></div><p>里面包含了四个文件，这里我们只需要关心data目录即可。在data目录中，你会发现很多文件，都是MATLAB和纯文本(.txt)格式，即:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> data</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 6052</span><br><span class="line">-rw-r--r-- 1 lone lone   10216 6月   1  2016 ILSVRC2015_clsloc_validation_blacklist.txt</span><br><span class="line">-rw-r--r-- 1 lone lone 1167074 6月   1  2016 ILSVRC2015_clsloc_validation_ground_truth.mat</span><br><span class="line">-rw-r--r-- 1 lone lone  194650 6月   1  2016 ILSVRC2015_clsloc_validation_ground_truth.txt</span><br><span class="line">-rw-r--r-- 1 lone lone    6455 6月   1  2016 ILSVRC2015_det_validation_blacklist.txt</span><br><span class="line">-rw-r--r-- 1 lone lone  635183 6月   1  2016 ILSVRC2015_det_validation_ground_truth.mat</span><br><span class="line">-rw-r--r-- 1 lone lone 2219755 9月   3  2016 ILSVRC2015_vid_validation_ground_truth.mat</span><br><span class="line">-rw-r--r-- 1 lone lone 1812198 9月   3  2016 ILSVRC2015_vid_validation_track_ground_truth.mat</span><br><span class="line">-rw-r--r-- 1 lone lone   24366 6月   1  2016 map_clsloc.txt</span><br><span class="line">-rw-r--r-- 1 lone lone    4479 6月   1  2016 map_det.txt</span><br><span class="line">-rw-r--r-- 1 lone lone     598 6月   1  2016 map_vid.txt</span><br><span class="line">-rw-r--r-- 1 lone lone   83277 6月   1  2016 meta_clsloc.mat</span><br><span class="line">-rw-r--r-- 1 lone lone   10355 6月   1  2016 meta_det.mat</span><br><span class="line">-rw-r--r-- 1 lone lone    1685 6月   1  2016 meta_vid.mat</span><br></pre></td></tr></tbody></table></figure></div><p>在这个目录中，我们最关心的是以下三个文件:</p><ul><li>map_clsloc.txt</li><li>ILSVRC2015_clsloc_validation_ground_truth.txt</li><li>ILSVRC2015_clsloc_validation_blacklist.txt</li></ul><p>map_clsloc.txt文件主要包含WordNet ID映射到图像真实的类标签数据，比如:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> head -n 10 map_clsloc.txt</span></span><br><span class="line">n02119789 1 kit_fox</span><br><span class="line">n02100735 2 English_setter</span><br><span class="line">n02110185 3 Siberian_husky</span><br><span class="line">n02096294 4 Australian_terrier</span><br><span class="line">n02102040 5 English_springer</span><br><span class="line">n02066245 6 grey_whale</span><br><span class="line">n02509815 7 lesser_panda</span><br><span class="line">n02124075 8 Egyptian_cat</span><br><span class="line">n02417914 9 ibex</span><br><span class="line">n02123394 10 Persian_cat</span><br></pre></td></tr></tbody></table></figure></div><p>我们可以看到<br>n02119789对应到kit_fox类标签。n02096294对应到Australian_terrier（是狗的一种品种）。val目录中的图像不包含任何WordNet ID信息，但是在ImageSets中包含一个val.txt文件，该文件包含了val数据集的文件名（没有图像扩展名），而在ILSVRC2015_clsloc_validation_ground_truth.txt中包含了val数据集的标签，即:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> head -n 10 ILSVRC2015_clsloc_validation_ground_truth.txt</span></span><br><span class="line">490</span><br><span class="line">361</span><br><span class="line">171</span><br><span class="line">822</span><br><span class="line">297</span><br><span class="line">482</span><br><span class="line">13</span><br><span class="line">704</span><br><span class="line">599</span><br><span class="line">164</span><br></pre></td></tr></tbody></table></figure></div><p>每一行都只有一个整数。取val.txt的第一行和ILSVRC2015_clsloc_validation_ground_truth的第一行。最后我们得到:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">(ILSVRC2015_val_0000000001,490)</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://lonepatient-1257945978.cos.ap-chengdu.myqcloud.com/18-10-25/4037842.jpg" class="fancybox fancybox.image" rel="group"><img src="https://lonepatient-1257945978.cos.ap-chengdu.myqcloud.com/18-10-25/4037842.jpg" alt=""></a></p><center>图13.2</center><p>如果我们打开ILSVRC2012_val_00000001.JPEG。我们将看到图13.2中的图像。很明显，这是一种蛇——但是哪种蛇呢?如果我们检查map_clsloc.txt，我们可以看到带有490的类标签ID是WordNet ID=n01751748，它是sea_snake:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">'490'</span> map_clsloc.txt</span></span><br><span class="line"></span><br><span class="line">n01751748 490 sea_snake</span><br></pre></td></tr></tbody></table></figure></div><p>因此，我们需要同时使用val.txt和ILSVRC2015_clsloc_validation_ground_truth.txt来构建我们的val数据集。</p><p>接下来，查看ILSVRC2015_clsloc_validation_blacklist.txt，即:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> head -n 10 ILSVRC2015_clsloc_validation_blacklist.txt</span></span><br><span class="line">36</span><br><span class="line">50</span><br><span class="line">56</span><br><span class="line">103</span><br><span class="line">127</span><br><span class="line">195</span><br><span class="line">199</span><br><span class="line">226</span><br><span class="line">230</span><br><span class="line">235</span><br></pre></td></tr></tbody></table></figure></div><p>正如我前面提到的，val数据集中包含一些类标签中过于模糊的图像数据。因此,ILSVRC组织者将这些图像数据标记为“黑名单”,这意味着这些数据不应该包含在val数据集中。在构建val数据集时，我们也需要排除这些黑名单id对应的图像数据。</p><p>可以看到，构建ImageNet数据集需要很多文件。我们不仅需要原始图像本身，还需要一些.txt文件，用于从原始train和val数据集中提取相应类标签。接下来，我们将对ImageNet数据进行预处理并保存到TFRecord文件中。</p><h2 id="构建ImageNet数据集"><a href="#构建ImageNet数据集" class="headerlink" title="构建ImageNet数据集"></a>构建ImageNet数据集</h2><p>对原始的ImageNet数据进行处理，主要是便于后续我们训练一个自定义的CNN网络结构，我们会将原始图像信息保存到TFRecord文件中。另外，我们还需要计算train数据集的RGB通道的均值，并保存磁盘中。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>我们将按照以下目录结构进行开发流程：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">--- tf_imagenet_alexnet</span><br><span class="line">| |--- pyimagesearch</span><br><span class="line">| |--- config</span><br><span class="line">| | |--- __init__.py</span><br><span class="line">| | |--- imagnet_alexnet_config.py</span><br><span class="line">| |--- imagenet</span><br><span class="line">| |--- outputs/</span><br><span class="line">| |--- build_imagenet.py</span><br><span class="line">| |--- test_alexnet.py</span><br><span class="line">| |--- train_alexnet.py</span><br></pre></td></tr></tbody></table></figure></div><p>正如目录和文件名所示，这个配置文件是为AlexNet网络准备的。在config目录中，包含了两个文件:</p><ul><li><strong>init</strong>.py</li><li>imagenet_alexnet_config.py</li></ul><p><strong>init</strong>.py文件将config转换成Python包，实际上可以通过import语句导入到我们自己的脚本中—这个文件使我们能够在实际配置中使用Python语法/库，从而构建网络时更加方便。imagenet_alexnet_config.py包含我们整个项目的配置信息。</p><p>在imagenet目录中新建一个tfrecords目录，主要是存放我们保存的TFRecord文件数据。</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir imagenet/tfrecords</span></span><br></pre></td></tr></tbody></table></figure></div><p>build_imagenet.py脚本主要是构建从输入图像文件到输出类标签的映射以及将数据保存到TFRecord文件中。train_alexnet.py脚本主要是在ImageNet数据集上从头开始训练AlexNet网络。最后,test_alexnet.py脚本主要是利用测试集验证AlexNet模型的性能。</p><p>本节我们主要是对ImageNet数据进行预处理。主要是完成build_imagenet.py脚本的内容。首先，我们先配置整个项目的配置信息。</p><p>打开imagenet_alexnet_config.py并写入以下代码:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Imagenet数据集路径</span></span><br><span class="line">BASE_PATH = <span class="string">'yourPath/ILSVRC'</span></span><br></pre></td></tr></tbody></table></figure></div><p>首先加载所需模块，这里path是os的一个子模块。path模块包含一个名为path的特殊变量。这是操作系统的路径分隔符。在Unix机器上，路径分隔符是/ -一个示例文件路径可能看起来像path/to/your/file.txt。然而，在Windows上，路径分隔符是\，比如示例文件路径path\your\file.txt。我们希望配置与操作系统无关，因此我们将使用path的sep变量。</p><p>然后我们定义个一个base_path，该路径下包含所有原始图像数据信息。</p><p>从BASE_PATH中，我们可以拼接出三个更重要的路径:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment"># 基于base path 定义原始图像和工具路径</span></span><br><span class="line">IMAGES_PATH = path.sep.join([BASE_PATH,<span class="string">'Data/CLS-LOC'</span>])</span><br><span class="line">IMAGE_SETS_PATH = path.sep.join([BASE_PATH,<span class="string">'ImageSets/CLS-LOC/'</span>])</span><br><span class="line">DEVKIT_PATH = path.sep.join([BASE_PATH,<span class="string">'devkit/data'</span>])</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>其中：</p><ul><li>IMAGES_PATH：包含train、val和test数据集。</li><li>IMAGE_SETS_PATH：包含重要train_cls.txt和val.txt。</li><li>DEVKIT_PATH：是DevKit所在位置的基本路径。</li></ul><p>接下来，定义WORD_IDS，即map_clsloc.txt文件的路径，它将1000个WordNet ID映射为：</p><ul><li>唯一的标识整数</li><li>实际可读标签。</li></ul><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment"># 定义WordNet IDs文件路径</span></span><br><span class="line">WORD_IDS = path.sep.join([DEVKIT_PATH,<span class="string">'map_clsloc.txt'</span>])</span><br></pre></td></tr></tbody></table></figure></div><p>为了构建train数据集，我们需要定义TRAIN_LIST，这个路径包含了120万个(部分)train数据的图像文件名:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment"># 定义training文件路径</span></span><br><span class="line">TRAIN_LIST = path.sep.join([IMAGE_SETS_PATH,<span class="string">'train_cls.txt'</span>])</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>接下来，我们需要定义一些val数据集相关配置:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment"># 定义验证集数据路径以及对应的标签文件路径</span></span><br><span class="line">VAL_LIST = path.sep.join([IMAGE_SETS_PATH,<span class="string">'val.txt'</span>])</span><br><span class="line">VAL_LABELS = path.sep.join([DEVKIT_PATH,<span class="string">'ILSVRC2015_clsloc_validation_ground_truth.txt'</span>])</span><br><span class="line"><span class="comment"># 定义val blacklisted 文件路径</span></span><br><span class="line">VAL_BLACKLIST = path.sep.join([DEVKIT_PATH,<span class="string">'ILSVRC2015_clsloc_validation_blacklist.txt'</span>])</span><br></pre></td></tr></tbody></table></figure></div><p>VAL_LIST：ImageSets目录中的val.txt文件。<strong>注意</strong>，val.txt列出了50,000个(部分)图像文件名。为了获得val数据的真实标签，我们需要定义val_tags路径—这样我们就可以将文件名和标签组合一起。最后，VAL_BLACKLIST文件包含已被列入黑名单的val数据中的唯一整数id。在构建ImageNet数据集时，我们需要注意确保这些图像不包含在验证数据中。</p><p>定义额外一些变量：<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment"># 定义类别个数</span></span><br><span class="line"><span class="comment"># 定义我们需要从train数据集中划分一个子集作为test数据集</span></span><br><span class="line">NUM_CLASSES = <span class="number">1000</span></span><br><span class="line">NUM_TEST_IMAGES = <span class="number">50</span> * NUM_CLASSES</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>ImageNet数据集中包含1000个类别图像，因此，NUM_CLASSES等于1000。为了得到我们的test数据集，我们需要从train数据集中提取一些子集作为test数据集。我们将NUM_TEST_IMAGES设置为50 * 1000 = 50000张图像。</p><p>接下来，我们定义保存TFRecord文件路径：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment"># 定义tfrecord文件的输出路径</span></span><br><span class="line">TF_OUTPUT = <span class="string">'imagenet'</span></span><br><span class="line">TRAIN_TFRECORD = path.sep.join([TF_OUTPUT,<span class="string">'tfrecords/train.tfrecords'</span>])</span><br><span class="line">VAL_TFRECORD  = path.sep.join([TF_OUTPUT,<span class="string">'tfrecords/val.tfrecords'</span>])</span><br><span class="line">TEST_TFRECORD = path.sep.join([TF_OUTPUT,<span class="string">'tfrecords/test.tfrecords'</span>])</span><br></pre></td></tr></tbody></table></figure></div><p>这里稍微提下，在TFRecord文件里保存的是二进制文件信息，而不是图像的numpy数组信息（HDF5保存方式），这样我们能够获得比之前使用的HDF5数据集更好的性能以及更小的磁盘使用量。</p><p>在构建数据集时，我们还需要对train数据集计算RGB三个颜色通道的平均值，并保存到磁盘中：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment"># 定义均值文件路径</span></span><br><span class="line">DATASET_MEAN = <span class="string">'outputs/imagenet_mean.json'</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>上面，我们完成了配置文件的创建，接下来，我们将处理图像数据，比如获取对应的标签信息，处理黑名单数据等等。在utils子目录中新建一个名为imagenethelper.py的文件，如下目录结构:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">--- pyimagesearch</span><br><span class="line">| |--- __init__.py</span><br><span class="line">| |--- callbacks</span><br><span class="line">| |--- io</span><br><span class="line">| |--- nn</span><br><span class="line">| |--- preprocessing</span><br><span class="line">| |--- utils</span><br><span class="line">| | |--- __init__.py</span><br><span class="line">| | |--- imagenettfrecord.py</span><br><span class="line">| | |--- imagenethelper.py</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>打开imagenethelper.py，并写入以下代码:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> progressbar</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageNetHelper</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,config)</span>:</span></span><br><span class="line">        <span class="comment"># 配置</span></span><br><span class="line">        self.config = config</span><br><span class="line">        <span class="comment"># 标签映射</span></span><br><span class="line">        self.labelMappings = self.buildClassLabels()</span><br><span class="line">        self.valBlacklist = self.buildBlacklist()</span><br></pre></td></tr></tbody></table></figure></div><p>上面我们定义了一个ImageNetHelper类。并且只需要传一个config的参数。所有的信息我们将从config变量中提取。</p><p>接下来，我们定义一个_pbar函数，该函数主要功能是显示进度条，方便我们实时监控脚本运行情况。<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pbar</span><span class="params">(self,maxval,name)</span>:</span></span><br><span class="line">    widgets = [name, progressbar.Percentage(), <span class="string">' '</span>,</span><br><span class="line">               progressbar.Bar(), <span class="string">' '</span>, progressbar.ETA()]</span><br><span class="line">    pbar = progressbar.ProgressBar(maxval=maxval,</span><br><span class="line">                                   widgets=widgets).start()</span><br><span class="line">    <span class="keyword">return</span> pbar</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>其中：</p><ul><li>maxval: 最大数据量</li><li>name：进度条显示名称</li></ul><p>接着，我们构建一个类标签映射字典:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildClassLabels</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 文件名映射类标签</span></span><br><span class="line">    <span class="comment"># n02110185 3 Siberian_husky</span></span><br><span class="line">    rows = open(self.config.WORD_IDS).read().strip().split(<span class="string">'\n'</span>)</span><br><span class="line">    labelMappings = {}</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>读取WORD_IDs文件的全部内容，并构建一个labelMappings字典，其中key为WordNet ID，值为整数类标签。</p><p>接下来，遍历整个文件内容，对于每一行，我们分解为一个3元祖，即：</p><ul><li>WordNet ID (wordID)。</li><li>唯一整数类标签ID(标签)。</li><li>实际可读标签。</li></ul><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    (wordId,label,hrLabel) = row.split(<span class="string">" "</span>)</span><br><span class="line">    labelMappings[wordId] = int(label) - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> labelMappings</span><br></pre></td></tr></tbody></table></figure></div><p>这里，我们对整数标签值减1，为什么要减1呢?ILSVRC提供的ImageNet工具是使用MATLAB构建的。MATLAB编程语言是单索引的(即从1开始计数)，而Python编程语言是零索引的(我们从0开始计数)。</p><p>接下来，处理黑名单id数据:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildBlacklist</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 验证集</span></span><br><span class="line">    rows = open(self.config.VAL_BLACKLIST).read()</span><br><span class="line">    rows = set(rows.strip().split(<span class="string">"\n"</span>))</span><br><span class="line">    <span class="keyword">return</span> rows</span><br></pre></td></tr></tbody></table></figure></div><p>处理train数据集：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTrainingSet</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 训练数据集</span></span><br><span class="line">    <span class="comment"># n01440764/n01440764_12131 189</span></span><br><span class="line">    rows = open(self.config.TRAIN_LIST).read().strip()</span><br><span class="line">    rows = rows.split(<span class="string">'\n'</span>)</span><br><span class="line">    paths = []</span><br><span class="line">    labels = []</span><br><span class="line">    probar = self._pbar(name=<span class="string">'building training set: '</span>,maxval=len(rows))</span><br></pre></td></tr></tbody></table></figure></div><p>TRAIN_LIST文件部分内容如下所示，我们将根据该结构提取数据：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">n01440764/n01440764_10026 1</span><br><span class="line">n01440764/n01440764_10027 2</span><br><span class="line">n01440764/n01440764_10029 3</span><br><span class="line">n01440764/n01440764_10040 4</span><br><span class="line">n01440764/n01440764_10042 5</span><br><span class="line">n01440764/n01440764_10043 6</span><br><span class="line">n01440764/n01440764_10048 7</span><br><span class="line">n01440764/n01440764_10066 8</span><br><span class="line">n01440764/n01440764_10074 9</span><br><span class="line">n01440764/n01440764_10095 10</span><br></pre></td></tr></tbody></table></figure></div><p>我们需要完成:</p><ul><li>通过字符拼接，获取完成的图像路径</li><li>提取图像对应的类标签</li></ul><p>对原始数据进行遍历:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="keyword">for</span> i,row <span class="keyword">in</span> enumerate(rows):</span><br><span class="line">    (partialPath,imageNum) = row.strip().split(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment"># 原始图像数据路径</span></span><br><span class="line">    path = os.path.sep.join([self.config.IMAGES_PATH,</span><br><span class="line">                             <span class="string">'train'</span>,<span class="string">'{}.JPEG'</span>.format(partialPath)])</span><br><span class="line">    <span class="comment"># wordId</span></span><br><span class="line">    wordId = partialPath.split(<span class="string">"/"</span>)[<span class="number">0</span>]</span><br><span class="line">    label = self.labelMappings[wordId]</span><br></pre></td></tr></tbody></table></figure></div><p>其中：</p><ul><li>partialPath对应图像的文件名，比如：n01440764/n01440764_10026。</li><li>imageNum变量只是一个计数器——它在构建train数据集时没有任何用途，可以忽略。</li></ul><p>一个完整的图像路径主要由：</p><ul><li>IMAGES_PATH：该路径包含了train、val和test数据目录</li><li>train字符串表示我们处理的train数据集</li><li>partialPath:图像的子目录以及文件名</li></ul><p>比如：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">yourPath/ILSVRC/Data/CLS-LOC/train/n15075141/n15075141_999.JPEG</span><br></pre></td></tr></tbody></table></figure></div><p>提取完完整图像路径和标签之后，我们对列表进行更新：<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">    paths.append(path)</span><br><span class="line">    labels.append(label)</span><br><span class="line">    probar.update(i)</span><br><span class="line">probar.finish()</span><br><span class="line"><span class="keyword">return</span> (np.array(paths),np.array(labels))</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>val数据处理步骤类似于train数据，即:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildValidationSet</span><span class="params">(self)</span>:</span></span><br><span class="line">    paths = []</span><br><span class="line">    labels = []</span><br><span class="line">    <span class="comment">#验证数据</span></span><br><span class="line">    <span class="comment"># ILSVRC2012_val_00000001 1</span></span><br><span class="line">    valFilenames = open(self.config.VAL_LIST).read()</span><br><span class="line">    valFilenames = valFilenames.strip().split(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证集对应的标签</span></span><br><span class="line">    <span class="comment"># 490</span></span><br><span class="line">    valLabels = open(self.config.VAL_LABELS).read()</span><br><span class="line">    valLabels = valLabels.strip().split(<span class="string">"\n"</span>)</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>构建完整的图像路径和对应的标签信息：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">probar = self._pbar(name=<span class="string">'building validation set: '</span>,maxval=len(valFilenames))</span><br><span class="line"><span class="keyword">for</span> i,(row,label) <span class="keyword">in</span> enumerate(zip(valFilenames,valLabels)):</span><br><span class="line">    (partialPath,imageNum)  =  row.strip().split(<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> imageNum  <span class="keyword">in</span> self.valBlacklist:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#val数据集真实图片数据</span></span><br><span class="line">    path = os.path.sep.join([self.config.IMAGES_PATH,<span class="string">'val'</span>,</span><br><span class="line">                             <span class="string">"{}.JPEG"</span>.format(partialPath)])</span><br><span class="line">    paths.append(path)</span><br><span class="line">    labels.append(int(label) - <span class="number">1</span>)</span><br><span class="line">    probar.update(i)</span><br><span class="line">probar.finish()</span><br><span class="line"><span class="keyword">return</span> (np.array(paths),np.array(labels))</span><br></pre></td></tr></tbody></table></figure></div><p>其中，我们增加一个黑名单id判断逻辑，如果该图像对应的id落在黑名单列表中，则直接过滤掉该图像信息。</p><p>以上我们完成图像数据的处理，接下来，我们将构建一个ImageNetTfrecord类，主要负责将图像数据写入TFRecord文件中。</p><h3 id="TFRecord"><a href="#TFRecord" class="headerlink" title="TFRecord"></a>TFRecord</h3><p>前面我们提到对于小数据，我们使用的是HDF5进行保存数据（我们直接将图像的numpy数组信息存入HDF5中），对于大数据集，我们建议使用TFRecord文件进行存储（当然，这里我们是使用Tensorflow框架为前提条件）。在该部分，我们将学习如何将我们的数据转换为Tensorflow标准格式。对于如何将原始数据转化为tfrecords文件，可以参考<a href="https://lonepatient.top/2018/06/01/tensorflow_tfrecord.html">该篇文章</a>，这里就不做详细描述。</p><p>总的来说，在我们将数据存储到TFRecord文件之前，我们应该将它填入名为Example的协议缓冲区中。</p><p>然后，我们将协议缓冲区序列化为字符串并将其写入TFRecord文件，协议缓冲区示例包含功能。</p><p>Feature是一种描述数据的协议，可以有三种类型：bytes，float和int64。 总之，要存储数据，您需要按照以下步骤操作：</p><ul><li>使用tf.python_io.TFRecordWriter打开TFRecord文件</li><li>使用tf.train.Int64List，tf.train.BytesList或tf.train.FloatList将数据转换为该功能的正确数据类型</li><li>使用tf.train.Feature创建一个功能，并将转换后的数据传递给它</li><li>使用tf.train.Example创建一个示例协议缓冲区，并将该功能传递给它</li><li>使用example.SerializeToString（）将Example序列化为字符串</li><li>使用writer.write将序列化示例写入TFRecord文件</li></ul><p>接下来，我们将按照上述步骤实现将数据保存到TFRecord文件的功能，在pyimagesearch的子目录utils中新建一个名为imagenettfrecord.py的文件，并写入以下代码:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageNetTfrecord</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,tfrecord_name)</span>:</span></span><br><span class="line">        self.tfrecord_name = tfrecord_name</span><br><span class="line">        self.tfwriter = tf.python_io.TFRecordWriter(self.tfrecord_name)</span><br></pre></td></tr></tbody></table></figure></div><p>首先，我们创建了一个ImageNetTfrecord类，该类只有一个参数，即:</p><ul><li>tfrecord_name: 保存数据的TFRecord文件路径</li></ul><p>并且，我们初始化了一个TFRecord文件写入器—tfwriter</p><p>接下来，我们定义数据类型：<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_int64_feature</span><span class="params">(self,value)</span>:</span></span><br><span class="line">    <span class="string">"""Wrapper for inserting int64 features into Example proto."""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, list):</span><br><span class="line">        value = [value]</span><br><span class="line">    <span class="keyword">return</span> tf.train.Feature(int64_list=tf.train.Int64List(value=value))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_float_feature</span><span class="params">(self,value)</span>:</span></span><br><span class="line">    <span class="string">"""Wrapper for inserting float features into Example proto."""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, list):</span><br><span class="line">        value = [value]</span><br><span class="line">    <span class="keyword">return</span> tf.train.Feature(float_list=tf.train.FloatList(value=value))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_bytes_feature</span><span class="params">(self,value)</span>:</span></span><br><span class="line">    <span class="string">"""Wrapper for inserting bytes features into Example proto."""</span></span><br><span class="line">    <span class="keyword">return</span> tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))</span><br></pre></td></tr></tbody></table></figure></div><p></p><p><strong>注意</strong>：在类型转换中，每一个value都是使用list进行包装的，即value=[value]</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_process_image</span><span class="params">(self,filename)</span>:</span></span><br><span class="line">    <span class="string">"""Process a single image file."""</span></span><br><span class="line">    <span class="keyword">with</span> tf.gfile.FastGFile(filename, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        image_data = f.read()</span><br><span class="line">        <span class="keyword">return</span> image_data</span><br></pre></td></tr></tbody></table></figure></div><p>这里我们使用tf.gfile.FastGFile该函数获取图像数据，该image_data不是图像的numpy数组数据，而是一个二进制信息。</p><p>接下来，将image_data保存到TFRecord文件中:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_save_one</span><span class="params">(self,label,filename,isTrain=True)</span>:</span></span><br><span class="line">    image_data = self._process_image(filename)</span><br><span class="line">    name = path.split(filename)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> isTrain:</span><br><span class="line">        example = tf.train.Example(features=tf.train.Features(feature={</span><br><span class="line">                    <span class="string">'image'</span>: self._bytes_feature(tf.compat.as_bytes(image_data)),</span><br><span class="line">                    <span class="string">'label'</span>: self._int64_feature(label),</span><br><span class="line">                    <span class="string">'name'</span>: self._bytes_feature(tf.compat.as_bytes(name))</span><br><span class="line">                }))</span><br><span class="line">        self.tfwriter.write(example.SerializeToString())</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>如果数据类型为test，由于test数据集没有对应标签信息，因此这里我们默认使用-1代替。即:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    label = int(<span class="number">-1</span>)</span><br><span class="line">    example = tf.train.Example(features=tf.train.Features(feature={</span><br><span class="line">            <span class="string">'image'</span>: self._bytes_feature(tf.compat.as_bytes(image_data)),</span><br><span class="line">            <span class="string">'label'</span>: self._int64_feature(label),</span><br><span class="line">            <span class="string">'name'</span>: self._bytes_feature(tf.compat.as_bytes(name))</span><br><span class="line">        }))</span><br><span class="line">    self.tfwriter.write(example.SerializeToString())</span><br></pre></td></tr></tbody></table></figure></div><p></p><h3 id="构建TFRecord和均值文件"><a href="#构建TFRecord和均值文件" class="headerlink" title="构建TFRecord和均值文件"></a>构建TFRecord和均值文件</h3><p>像前几节的build_*.py脚本一样，build_imagenet.py主要实现:</p><ul><li>建立training数据集</li><li>建立validation数据集</li><li>从training数据集中提取一小部分子集作为testing数据集</li><li>将数据集写入TFRecord文件，并保存到磁盘中</li><li>计算train数据集的RGB通道均值数据，并保存到磁盘中</li></ul><p>在pyimagesearch根目录下，新建一个名为build_imagenet.py文件，并写入以下代码:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> imagenet_alexnet_config <span class="keyword">as</span> config</span><br><span class="line"><span class="keyword">from</span> pyimagesearch.utils.imagenethelper <span class="keyword">import</span> ImageNetHelper</span><br><span class="line"><span class="keyword">from</span> pyimagesearch.utils.imagenettfrecord <span class="keyword">import</span> ImageNetTfrecord</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>这里加载了我们之前构建好的配置模块imagenet_alexnet_config，以及数据预处理模块ImageNetHelper和写入TFRecord文件模块ImageNetTfrecord。</p><p>接下来，构建training数据集和validation数据集以及对应的标签数据：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">print(<span class="string">'[INFO] loading image paths...'</span>)</span><br><span class="line">inh = ImageNetHelper(config)</span><br><span class="line">(trainPaths,trainLabels) = inh.buildTrainingSet()</span><br><span class="line">(valPaths,valLabels) = inh.buildValidationSet()</span><br></pre></td></tr></tbody></table></figure></div><p>然后，我们从trainPaths和trainlabel提取出NUM_TEST_IMAGES大小数据量，作为我们的testing数据，即:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">print(<span class="string">'[INFO] constructing splits...'</span>)</span><br><span class="line">split = train_test_split(trainPaths,trainLabels,</span><br><span class="line">                         test_size = config.NUM_TEST_IMAGES,stratify=trainLabels,</span><br><span class="line">                         random_state=<span class="number">42</span>)</span><br><span class="line">trainPaths,testPaths,trainLabels,testLabels = split</span><br></pre></td></tr></tbody></table></figure></div><p>接着，我们将三类数据集合并到一个datasets列表中:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">datasets = [</span><br><span class="line">    (<span class="string">'train'</span>,trainPaths,trainLabels,config.TRAIN_TFRECORD),</span><br><span class="line">    (<span class="string">'val'</span>,valPaths,valLabels,config.VAL_TFRECORD),</span><br><span class="line">    (<span class="string">'test'</span>,testPaths,testLabels,config.TEST_TFRECORD)</span><br><span class="line">]</span><br><span class="line">(R,G,B) = [],[],[]</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>其中，列表中的每一个value由一个4元组组成，即:</p><ul><li>数据的类型</li><li>图像数据路径</li><li>图像数据对应标签</li><li>TFRecord文件名</li></ul><p>接下来，遍历datasets数据列表:</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="keyword">for</span> (dType,paths,labels,outputPath) <span class="keyword">in</span> datasets:</span><br><span class="line">    print(<span class="string">'[INFO] building {}...'</span>.format(outputPath))</span><br><span class="line">    inr = ImageNetTfrecord(outputPath)</span><br><span class="line"></span><br><span class="line">    probar = inh._pbar(name=<span class="string">'Building %s List: '</span>%dType,maxval=len(paths))</span><br></pre></td></tr></tbody></table></figure></div><p>首先，初始化ImageNetTfrecord类，用来将数据写入TFRecord文件中，其次，调用inh类中的进度条函数_pbar，该函数有助于我们实时掌握数据处理过程。</p><p>对每一类型数据集进行遍历:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="keyword">for</span> (i,(path,label)) <span class="keyword">in</span> enumerate(zip(paths,labels)):</span><br><span class="line">    inr._save_one(label=label, filename=path, isTrain=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment">#　如果是train数据，则计算RGB均值信息</span></span><br><span class="line">    <span class="keyword">if</span> dType == <span class="string">'train'</span>:</span><br><span class="line">        image = cv2.imread(path)</span><br><span class="line">        (b,g,r) = cv2.mean(image)[:<span class="number">3</span>]</span><br><span class="line">        R.append(r)</span><br><span class="line">        G.append(g)</span><br><span class="line">        B.append(b)</span><br><span class="line">        probar.update(i)</span><br><span class="line">probar.finish()</span><br><span class="line">inr.tfwriter.close()</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>将每条数据写入TFRecord文件中，如果数据类型为train，我们还需计算该数据集的RGB颜色通道均值，并更新相应的通道列表数据。</p><p>最后，将均值文件写入磁盘中：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line">print(<span class="string">'[INFO] serializing means...'</span>)</span><br><span class="line">D = {<span class="string">'R'</span>:np.mean(R),<span class="string">'G'</span>:np.mean(G),<span class="string">'B'</span>:np.mean(B)}</span><br><span class="line"><span class="keyword">with</span> open(config.DATASET_MEAN,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(json.dumps(D))</span><br></pre></td></tr></tbody></table></figure></div><p>以上，我们完成了整个执行脚本的构建，接着执行build_imagenet.py脚本，完成整个数据处理工作:<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> python build_imagenet.py</span></span><br><span class="line">[INFO] loading image paths...</span><br><span class="line">building training set: 100% |########################################################| Time:  0:00:02</span><br><span class="line">building validation set: 100% |########################################################| Time:  0:00:00</span><br><span class="line">[INFO] constructing splits...</span><br><span class="line">[INFO] building imagenet/tfrecords/train.tfrecords...</span><br><span class="line">Building train List:   0% |</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>由于train数据集，我们需要用cv2模块读取图像的numpy数组数据，并计算RGB通道均值数据，因此相对于val和test数据，我们需要更多的时间处理train数据集。并且由于我们所需要做的只是将图像路径和标签写入文件(不需要额外的I/O)，所以val数据和test数据会很快的写入TFRecord文件中并保存到磁盘中。</p><p>当执行完之后，你将在imagenet目录中tfrecords子目录中看到三个文件；<br></p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><button class="btn-copy" data-clipboard-snippet="">  <i class="fa fa-clipboard"></i><span>copy</span></button><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lht</span></span><br><span class="line">5.4G  test.tfrecords</span><br><span class="line">6.1G  val.tfrecords</span><br><span class="line">132G  train.tfrecords</span><br></pre></td></tr></tbody></table></figure></div><p></p><p>我们可以看到train.tfrecords文件是最大的，达到了132G。val.tfrecords文件为6.1G和test.tfrecords文件大小为5.4G。这样做的好处是，我们可以将整个ImageNet数据集有效地压缩到压缩记录文件中。压缩不仅节省了我们的磁盘空间，而且由于需要执行的I/O操作更少，它还将大大加快训练过程。</p><p>这种方法与HDF5方法不同，HDF5方法需要存储每个图像的原始数字数组信息。如果我们使用HDF5(256x256x3图像)存储ImageNet，结果文件将超过1.9TB，所以对于大数据集，使用TFRecord文件进行存储比较合理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本章中，我们学习了如何预处理ImageNet数据集。首先，我们介绍了ImageNet数据文件结构以及数据说明，之后，我们构建了整个项目的配置文件，一般而言，配置文件不会怎么变化，接着，我们创建了两个py脚本，一个是关于ImageNet数据处理脚本，另一个是将数据写入TFRecord文件脚本。最后，脚本build_imagenet.py完成了整个数据集构造过程。后面，我们将直接从TFRecord文件中读取数据，并训练深度学习模型。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/深度学习/" rel="tag"><i class="fa fa-envira"></i> 深度学习</a> <a href="/tags/TensorFlow/" rel="tag"><i class="fa fa-envira"></i> TensorFlow</a> <a href="/tags/计算机视觉/" rel="tag"><i class="fa fa-envira"></i> 计算机视觉</a></div><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/07/02/Conditional-Random-Fields.html" rel="prev" title="条件随机场-CRF"><i class="fa fa-chevron-left"></i> 条件随机场-CRF</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/06/30/The_whole_process_of_knowledge_graph_construction_from_bottom_to_top.html" rel="next" title="一文揭秘！自底向上构建知识图谱全过程">一文揭秘！自底向上构建知识图谱全过程 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article>
https://lonepatient.top/2018/07/02/Deep_Learning_For_Computer_Vision_With_Python_PB_13.html
